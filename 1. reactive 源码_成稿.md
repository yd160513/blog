# 前言

用了很长时间的 `componsition-api` 了，最近想看看源码，抱着单纯的学习心态先从 `reactive` 开始吧。

个人习惯：

- 看代码要带着问题去看，不要盲目的去看
- 问题就是这次看源码的主线，要围绕着主线去展开，过程中和主线没有多大关系的该忽略掉就忽略掉
- 开源项目一般都封装的比较好，有可能一个函数中会引用多个文件中的函数，每次跳转的时候将跳转的目录记下来，避免跳着跳着就不知道跳哪去了
- 进入到一个文件中先将函数都收起来，便于查看

## 前置准备

- 把 `vue-next` 从 [github](https://github.com/vuejs/vue-next) 上把项目 `clone` 下来。

- 通过 `yarn install` 安装依赖。

- 将 `package.json` 中 `dev` 脚本增加 `sourcemap` 最终命令为: `"dev": "node scripts/dev.js --sourcemap"`。

- 因为 `vue3` 是通过 `rollup` 打包的，所以还需要安装 `rollup`。

- 执行 `npm run dev` 在 <span style="color=#4185c4">package/vue/</span> 目录下会生成一个 `dist` 文件夹。

- 在 <span style="color=#4185c4">package/vue/examples/</span> 目录下新建 `init.html` 文件。

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <body>
    <div id="app">
      <h1>hello</h1>
    </div>
    <script src="../dist/vue.global.js"></script>
    <script>
      const { watch, watchEffect, createApp, reactive } = Vue
      debugger
      const data = reactive({
        a: 1,
        b: 2,
        count: 0
      })
    </script>
  </body>
  </html>
  ```

- 然后将这个文件以服务的形式跑起来进入 `debug`，通过断点可以进入到 `reactive` 函数。

# 数据响应式 `Reactive`

`reactive` 函数一开始就判断了如果传入的 `target` 如果是一个只读的对象则 `return target`。

紧接着调用了 `createReactiveObject` 函数，先来看一下函数对应的参数：

1. `target` 将要被代理的对象
2. 是否只读
3. `baseHandlers` 和 `collectionHandlers` 都是 `proxy` 的 `handler`，对应的实参分别是 `mutableHandlers` 和 `mutableCollectionHandlers`，根据 `target` 类型来决定 `proxy` 的 `handler`
4. `reactiveMap` 是当前文件中声明的一个常量，用于存储依赖，现在只需要它是一个 `weakMap` 类型数据就好

函数一开始对 `target` 做了几种情况的判断，针对不同情况做了对应的 `return`。

主要关注点是这一段代码

```typescript
const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
)
```

这里会根据 `target` 的类型来选择对应的 `handler`，`targetType` 是调用 `getTargetType` 函数的返回值，`targetType` 为 `Map/Set/WeakMap/WeakSet` 的时候会将 `collectionHandlers` 传入 `Proxy`，反之采用 `baseHandlers`。

## `baseHandlers` 

### `get` 对应的 `createGetter` 的返回值

`createGetter` 接收两个参数 `isReadonly` 和 `shallow`，在 `get` 方法中先判断了三种特殊情况，针对每种不同情况 return 了不同的值，其中在这几个判断中用到的 `shallowReadonlyMap/readonlyMap/shallowReactiveMap` 它们的类型和 `reactiveMap` 的类型都一样都是 `weakMap`，只不过是对应不同的状态。

下边判断了是不是数组，如果是数组并且 `isReadonly` 为 `false` 且 `key` 是 `includes/indexOf/lastIndexOf/push/pop/shift/unshift/splice` 其中的一个的话则执行

```typescript
return Reflect.get(arrayInstrumentations, key, receiver)
```

也就是对上述那些方法进行了重写。这段代码是为了解决边缘情况

> `includes/indexOf/lastIndexOf` 是为了避免产生以下情况
>
> ```
> const obj = {}
> const arr = reactive([obj])
> arr.indexOf(obj) // -1 正常情况下应该返回的是 0
> ```

> `push/pop/shift/unshift/splice` 是为了避免这些改变数组长度的方法在某些情况下进入死循环

再往下获取了 `key` 在 `target` 中对应的值

```typescript
const res = Reflect.get(target, key, receiver)
```

接着判断 `key` 是 `symbol` 的情况。如果 `isReadonly` 为 `false` 则调用 `track` 函数进行依赖收集。

`track` 这个函数往后放一下，看完这个 `get` 函数后再回头来看 `track`。

接着又判断了 `createGetter` 传入的 `shallow` 为 `true` 和 `res` 为 `ref` 类型的这两种情况。

如果 `res` 还是一个对象并且 `isReadonly` 为 `false` 则递归调用 `reactive` 函数，反之调用 `readonly` 函数。

从调用 `reactive` 函数这里可以看出，`vue3` 中的响应式和 `vue2` 的差别不仅在 `definePrototype` 和 `proxy` 上，在处理响应式的时机上也有变化，`definePrototype` 是一上来就将 `target` 上的所有属性都变成响应式的，但是 `vue3` 是在当你去读取这个 `key` 的时候，采取将 `key` 对应的 value 转换成响应式的。

接下来去看一下 `track` 函数







### `set` 对应的 `createSetter` 的返回值

### `deleteProperty` 

### `has ` 

### `ownKeys` 

