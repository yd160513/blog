# 前言

在看这一块代码的时候我选择从测试用例入手：

```typescript
describe('compiler: integration tests', () => {
  const source = `
    <div id="foo" :class="bar.baz">
    {{ world.burn() }}
    <div v-if="ok">yes</div>
    <template v-else>no</template>
    <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
    </div>
  `.trim()

  test('function mode', () => {
    const result = compile(source, {
      sourceMap: true,
      filename: `foo.vue`
    })
  })
})
```

这里的调用 compile 函数就是编译的总入口。

在看模板编译这里需要了解的前置知识：

> Vue 的编译分为三个阶段，分别是 parse、transform 和 condegen。parse 阶段负责将模板字符串解析为抽象语法树 AST; transform 阶段是对 AST 进行转换，也就是在 AST 上增加一些标记，方便在 condegen 阶段更快生成可执行代码，也可以理解成对 AST 的优化; condegen 阶段就是根据 AST 生成对应的 render 函数字符串。

接下来开始进入 compile 方法。

# 解析

解析是整个模板编译的第一步，对应的伪代码如下：

```typescript
const ast = baseParse(template, options)
```

接下来可以看一下 baseParse 中的代码

```typescript
export function baseParse(
 content: string,
 options: ParserOptions = {}
): RootNode {
  const context = createParserContext(content, options)
  const start = getCursor(context)
  return createRoot(
    parseChildren(context, TextModes.DATA, []),
    getSelection(context, start)
  )
}
```

这里先创建了一个解析的上下文得到 context; 后续调用了 getCursor 方法，这个方法其实就是从 context 中取出了 column、line、offset 三个值返回一个对象赋值给了 start; 最后将 createRoot 的返回值 return 了出去，从这里可以知道解析的核心逻辑是在 createRoot 方法中。

因为调用 createRoot 的时候将 parseChildren 和 getSelection 两个方法的返回值传了进去，所以需要先看一下这两个方法。

## createRoot 的参数一: parseChildren 方法的返回值

通过这个方法名称也可以看出来这个方法是用来解析子节点的。

看完整个方法之后可以得出的**结论**是

1. 解析标签是通过正则来匹配各个标签以及这个标签是开始标签还是结束标签。
2. 在匹配的过程中会将当前匹配的开始标签放到缓存中，如果当前标签有自己子节点的话会先去解析子节点并将子节点的开始标签也 push 到缓存中，只有当子节点解析完成之后，才会将子节点的开始标签从缓存中取出来，这个时候父节点就知道子节点解析完成了，然后开始解析父节点的后半部分。
3. 通过第 2 点也可以知道在解析的过程中是遵循了深度优先的原则。

函数的返回值就是解析完成后的子节点组成的 AST。

## createRoot 的参数而: getSelection 方法的返回值

这个方法是用来获取当前节点的在源代码中的位置信息，最终的返回值就是这些位置信息。

```typescript
return {
  start,
  end,
  source: context.originalSource.slice(start.offset, end.offset)
}
```

知道了 parseChildren 和 getSelection 两个方法的返回值后就可以去看 createRoot 方法了。

## createRoot 方法

```typescript
export function createRoot(
  children: TemplateChildNode[],
  loc = locStub
): RootNode {
  return {
    type: NodeTypes.ROOT,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc
  }
}
```

这个方法很简单，就是创建了一个根节点的 AST 并把 type 设置为了 ROOT，children 就是 parseChildren 方法的返回值，也就是所有子节点的 AST。

当执行完 createRoot 方法之后，模板对应的 AST 就全部生成了。

# 优化

优化 AST 阶段对应的是 transform 方法。

还是先来看 transform 的调用

```typescript
transform(
  ast,
  extend({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...(options.nodeTransforms || []) // user transforms
    ],
    directiveTransforms: extend(
      {},
      directiveTransforms,
      options.directiveTransforms || {} // user transforms
    )
  })
)
```

这里需要说明的参数有

1. prefixIdentifiers: 这个参数决定了代码生成方式。代码生成方式有两种:
   - function 模式，特点是使用 `const { helpers... } = Vue` 的方式来引入帮助函数。向外导出使用 `return` 返回整个 `render()` 函数。
   - module 模式，特点是使用 es6 模块来导入导出函数，也就是使用 import 和 export。
   
2. nodeTransforms 和 directiveTransforms 这两个参数分别是针对 node 和 directive 的单独优化。这两个参数都是从 getBaseTransformPreset 方法中得到的，在这个方法中可以看到这两个参数分别对应的是什么

   - nodeTransforms 对应的是

     ```typescript
     transformOnce,
     transformIf,
     transformFor,
     ...[transformFilter],
     ...[
         trackVForSlotScopes,
         transformExpression
     ],
     transformSlotOutlet,
     transformElement,
     trackSlotScopes,
     transformText
     ```

   - directiveTransforms 对应的是

     ```typescript
     on: transformOn,
     bind: transformBind,
     model: transformModel
     ```

   这就可以看出在各种节点和指令都会有专门的优化方法。

看完这些参数就可以去看 transform 方法了。

# 生成可执行代码



# 参考链接

- [Vue3 模板编译原理](https://segmentfault.com/a/1190000023594560) 
- [从编译过程，理解 Vue3 静态节点提升 | 源码解读](https://juejin.cn/post/6874419253865365511) 

