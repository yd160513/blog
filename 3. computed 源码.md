# computed



# 遇到的问题

- 在 `ComputedRefImpl` 中为什么要传入一个调度器

  用来控制当前计算属性所订阅的属性发生改变时，用来控制计算属性的调度时机

- `_dirty` 是干什么用，`get` 的这个判断是干啥用的

  ```typescript
  const self = toRaw(this)
  if (self._dirty) {
      self._value = this.effect()
      self._dirty = false
  }
  ```

  控制计算属性是否需要重新计算，在第一次计算之后这个值就会变成 `false`，并将值缓存起来。当计算属性内所依赖的属性没有发生变化的条件下再次获取计算属性的值，这个时候 `_dirty` 的值为 `false` 则会直接 `return _value` 将上一次缓存的值返回。


# 总结

- `computed` 会进行缓存上一次计算出来的结果，当计算属性所依赖的属性没有发生改变时，访问计算属性会返回之前在 `_value` 缓存的值。
- `computed` 是惰性的

