# 前言

在看 `reactive` 源码的时候发现单独调用 `reactive` 函数并没有收集依赖，那么什么时候才会收集依赖呢，我把之前的 demo 改了改，加入了 `watchEffect` 之后发现在 `watchEffect` 中用到的属性会被收集依赖，那为什么调用了 `watchEffect` 之后就会收集依赖呢，让我们进入到源码中一探究竟吧。

更改后的 demo:

```html
<!DOCTYPE html>
<html lang="en">
    <body>
        <div id="app">
            <h1>hello</h1>
        </div>
        <script src="../dist/vue.global.js"></script>
        <script>
            const { watch, watchEffect, createApp, reactive } = Vue
            const data = reactive({
                a: 1,
                b: 2,
                count: 0
            })
            debugger
            watch((event) => {
                debugger
                return data.a
            }, (newVal, oldVale) => {
                debugger
            })
            setTimeout(() => {
                data.a = 6
            }, 5000)  
            // 收集依赖 track()
            watchEffect(() => {
                /**
       			 * data.a // getter
       			 * data.count = // setter trigger()
       			 **/
                data.count = data.a + 1
                console.log('count: ', data.count)
            })
        </script>
    </body>
</html>
```

我们还是以 `debug` 的方式进入。

# 开始吧

在 demo 中我们加入了 `watch` 函数是因为 `watch` 和 `watchEffect` 都调用了同一个函数 `doWatch`，只不过是参数不一样。

接下来进入 `doWatch` 函数，`doWatch` 接收四个参数

- `source` 监听的源
- `callback` 监听的回调函数
- `options` 监听的其他选项
- `currentInstance` 当前组件实例

这个时候看一下 `watchEffect` 和 `watch` 调用它的时候有什么区别

- `watchEffect` 在调用的时候 `callback` 传入的是 `null` 
- `watch` 在调用的时候传入的是 `callback`，这个 `callback` 也是 `watch` 函数的一个参数

回到 `doWatch` 函数，先做了一个开发环境下的警告处理，又定义了一个 `warnInvalidSource` 警告处理的方法。

下面判断了 `source` 分别是 `ref/reactive/array/function` 类型的时候 `getter` 函数的不同定义，但是 `getter` 的宗旨是不变的，就是用来求值: 

- `ref` 类型通过 `.value` 获取值

  ```typescript
  const refVal = ref(0)
  watch(ref, (newVal, oldVal) => {})
  ```

- `reactive` 类型直接将 `source` `retrun`

  ```typescript
  const data = reactive({
      a: 1
  })
  watch(data, (newVal, oldVal) => {})
  ```

- `array` 类型要针对每一项的类型来求值

  ```typescript
  const refVal = ref(0)
  const data = reactive({})
  const fun = () => 0
  const arr = [
      refVal, // .value 求值
      data, // 递归调用 traverse 函数 return data
      fun // 调用 callWithErrorHandling 函数执行 source
  ]
  ```

  `callWithErrorHandling` 函数就是调用第一个参数，如果有第四个参数，则在调用的时候将其传入。























下面判断了 `source` 是 `ref/reactive/array`这三种类型的时候分别对定义不同的 `getter` 函数，`getter` 就是用来求对应 `source` 的值， 如果是这三种情况肯定是由 `watch` 来调用的。

如果 `source` 是一个 `function` 类型的话就需要判断有没有 `callback` 了，有 `callback` 说明还是 `watch` 调用的，还需要定义对应的 `getter`。如果是 `function` 类型的话，`getter` 里边调用了 `callWithErrorHandling` 函数，这个函数里边就是调用执行了第一个参数，如果有第四个参数的话，会再调用的时候将第四个作为参数传进去。



 