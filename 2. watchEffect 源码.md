# 前言

在看 `reactive` 源码的时候发现单独调用 `reactive` 函数并没有收集依赖，那么什么时候才会收集依赖呢，我把之前的 demo 改了改，加入了 `watchEffect` 之后发现在 `watchEffect` 中用到的属性会被收集依赖，那为什么调用了 `watchEffect` 之后就会收集依赖呢，让我们进入到源码中一探究竟吧。

更改后的 demo:

```html
...
<script>
    const { watch, watchEffect, createApp, reactive } = Vue
    const data = reactive({
        a: 1,
        b: 2,
        count: 0
    })
    debugger
    watch((event) => {
        debugger
        return data.a
    }, (newVal, oldVale) => {
        debugger
    })
    setTimeout(() => {
        data.a = 6
    }, 5000)  
    // 收集依赖 track()
    watchEffect(() => {
        /**
       	 * data.a // getter
       	 * data.count = // setter trigger()
       	 **/
        data.count = data.a + 1
        console.log('count: ', data.count)
    })
</script>
...
```

我们还是以 `debug` 的方式进入。

# 开始吧

在 demo 中我们加入了 `watch` 函数是因为 `watch` 和 `watchEffect` 都调用了同一个函数 `doWatch`，只不过是参数不一样。

接下来进入 `doWatch` 函数，`doWatch` 接收四个参数

- `source` 监听的源
- `callback` 监听的回调函数
- `options` 监听的其他选项
- `currentInstance` 当前组件实例

这个时候看一下 `watchEffect` 和 `watch` 调用它的时候有什么区别

- `watchEffect` 在调用的时候 `callback` 传入的是 `null` 
- `watch` 在调用的时候传入的是 `callback`，这个 `callback` 也是 `watch` 函数的一个参数

回到 `doWatch` 函数，先做了一个开发环境下的警告处理，又定义了一个 `warnInvalidSource` 警告处理的方法。

下面判断了 `source` 分别是 `ref、reactive、array、function` 类型的时候 `getter` 函数的不同定义，但是 `getter` 的宗旨是不变的，就是用来求值: 

- `ref` 类型通过 `.value` 获取值

  ```typescript
  const refVal = ref(0)
  watch(ref, (newVal, oldVal) => {})
  ```

- `reactive` 类型直接将 `source` `retrun`

  ```typescript
  const data = reactive({
      a: 1
  })
  watch(data, (newVal, oldVal) => {})
  ```

- `array` 类型要针对每一项的类型来求值

  ```typescript
  const refVal = ref(0)
  const data = reactive({})
  const fun = () => 0
  const arr = [
      refVal, // .value 求值
      data, // 递归调用 traverse 函数
      fun // 调用 callWithErrorHandling 函数执行 source
  ]
  ```

  `traverse` 函数是将数组的每一项传进去，判断这一项是什么类型，递归调用，然后将其结果 return。
  
  `callWithErrorHandling` 函数就是调用第一个参数，如果有第四个参数，则在调用的时候将其传入。

- `function` 类型就要判断有没有 `callback`，有的话调用 `callWithErrorHandling` 函数来执行 `source`。没有的话说明是 `watchEffect` 调用的，这时候 `getter` 函数中如果当前实例被卸载了则 `return`，然后调用 `cleanup` 函数，调用 `callWithAsyncErrorHandling` 函数执行 `source`。`cleanup` 函数在下边会有定义，`callWithAsyncErrorHandling` 函数和 `callWithErrorHandling` 函数的作用是一样的，区别在于 `callWithAsyncErrorHandling` 多了一个对 `promise` 错误捕获。在调用 `callWithAsyncErrorHandling` 的时候传入了第四个参数，实参为 `onInvalidate` 函数，这样就可以解释我们在调用 `watchEffect` 的时候，回调函数里边会有一个参数，参数值就是 `onInvalidate ` 函数。**这里的这个回调函数是干啥用的呢？后面来解决这个问题**。

做完上边的判断下边是做了对 2.x 版本监听数组的一个兼容。

然后又判断了如果是由 `watch` 调用的并且设置了 `deep` 属性为 `true` 则进行深度监听。

后边定义了上边提到的 `cleanup` 和 `onInvalidate`，

```typescript
let cleanup: () => void
let onInvalidate: InvalidateCbRegistrator = (fn: () => void) => {
    cleanup = runner.options.onStop = () => {
        // 这里会调用 fn
        callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)
    }
}
```

`onInvalidate` 函数接收一个 `function` 类型的参数 `fn`，函数内部是将 `fn` 注册到了当前 `effect` 的 `onStop` 函数上，然后将 `onStop` 又赋值给了 `cleanup`，这样做的好处是，在执行 `cleanup` 的时候 `fn` 也就可以被执行了。

后边针对服务端渲染做了处理，当由 `watchEffect` 调用的时候直接调用 `getter`，反之由 `watch` 调用并且 `immediate` 为 `true` 的时候立刻调用 `callback` 并返回，因为 `watch` 他是惰性的，如果设置了 `immediate` 为 `true` 则需要立刻返回。

下面定义了 `job` 函数，`job` 就是来执行 `watch` 和 `watchEffecct` 两种不同的操作的。

```typescript
const job: SchedulerJob = () => { 
    if (!runner.active) {
        return
    }

    if (cb) {
		// 由 watch 调用
       	...
    }
    else {
        // 对于 watchEffect 直接调用传入的函数
        runner()
    }
}
```

`job` 内部如果是由 `watch` 调用的则如果 `newValue` 和 `oldValue` 不一样的话，调用 `cleanup`，并且调用 `callback`。

如果是由 `watchEffect` 调用的则直接调用传入的函数，这个 `runner` 函数下边会有说。

下边有这么一行代码

```typescript
job.allowRecurse = !!cb
```

根据代码中的注释可以知道这行代码的意思是允许递归调用，也就是允许 watch 的 callback 中修改正在监听的值，使当前这个 watch 可以监听到正在监听的这个值被改变了。也就是这样

```typescript
const num = ref(0)
watch(num, (newVal, oldVal) => {
    if (newVal < 10) {
        num.value = newVal + 1
    }
})
```

继续往下看

```typescript
let scheduler: ReactiveEffectOptions['scheduler']
// 同步直接 job
if (flush === 'sync') {
    scheduler = job as any // the scheduler function gets called directly
} else if (flush === 'post') {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)
} else {
    // default: 'pre'
    scheduler = () => {
        if (!instance || instance.isMounted) {
            queuePreFlushCb(job)
        } else {
            // with 'pre' option, the first call must happen before
            // the component is mounted so it is called synchronously.
            // instance 存在但是实例还没有挂载，这个时候需要直接执行 job
            job()
        }
    }
}
```

这里定义了一个调度器，调度器的作用是根据 `flush` 来判断更新时机，也就是什么时候去调用上边定义的 `job`。`flush` 等于 `sync` 的时候同步调用；等于 `post` 的时候异步调用，将 `job` 添加到微任务队列中，调用时机交给事件循环；等于 `pre` 也就是默认的时候有两种情况，第一种是组件实例不存在或者实例已经挂载的时候也需要将 `job` 添加到任务队列中，第二种是组件实例存在但是还没有挂载这个时候直接执行 `job`。

再往下就定义了 `runner` 这个 `runner` 在前边也提到过，一次是在定义 `onInvalidate` 函数中定义了 `runner` 上的 `onStop` 函数，另外一次是在定义 `job` 的时候如果是 `watchEffect` 调用的话直接执行了 `runner`。这次我们来看看这个 `runner` 到底是什么

```typescript
const runner = effect(getter, {
    lazy: true,
    onTrack,
    onTrigger,
    scheduler
})
```

这里终于用到了上边定义的 `getter` 和调度器 `scheduler`。进入 `effect` 函数

```typescript
export function effect<T = any>(
fn: () => T,
 options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect<T> {
    // 如果 fn 是一个 effect 则将 fn 改为原始对象
    if (isEffect(fn)) {
        fn = fn.raw
    }
    const effect = createReactiveEffect(fn, options)
    if (!options.lazy) {
        effect()
    }
    return effect
}
```

它在一首一尾有两个判断，如果传入的 `fn` 是一个 `effect` 则将其改为原始对象；如果传入的是 `lazy` 为 `false` 则需要调用这个方法内的 `effect`， 而这个 `effect` 是在这两个判断中间的 ` createReactiveEffect` 函数的返回值。看到这里就先不去看 `createReactiveEffect` 函数了，先将其记下，等把 `doWatch` 这个方法看完之后再回头来看这个函数。

定义完 `runner` 之后又执行了 `recordInstanceBoundEffect` 函数，这个函数的作用是将 `runner` `push` 到当前组件实例的 `effects` 数组中。也就是当前的 `runner` 要和当前的组件实例绑定，以便在销毁组件实例的时候一同销毁。

后边判断了如果是 `watch` 就判断了 `immediate` 是否为 `true` 如果是的话则会立即调用 `job`，反之调用 `runner` 即可，并将 `runner` 的返回值给 `oldValue`，以便后期 `newvalue` 和 `oldValue` 做比对。

如果不是则判断 `flush` 是否等于 `post` 为 `true` 则调用 `queuePostRenderEffect` 函数将 `runner` 放到事件循环中，交给事件循环去触发。

如果上边的条件都不满足则直接调用 `runner` 函数。

最后 `return` 了一个函数，函数中调用了 `stop` 函数，如果实例存在再去调用 `remove` 函数删除当前实例上的这个 `runner`。这也就正好和 **`watchEffect` 会返回一个函数去停止当前这个 `watchEffect`** 这个定义对上了。

## createReactiveEffect

前边提到了























# 产生的问题

- `watchEffect` 函数中的回调函数中会有一个参数，参数是 `onInvalidate ` 函数，这个函数是做什么的
- `createReactiveEffect` 函数的内部实现















 