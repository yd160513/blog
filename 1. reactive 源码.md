## 数据响应式

 1. reactive() // packages\reactivity\src\reactive.ts

 2. createReactiveObject() // packages\reactivity\src\reactive.ts

    ```javascript
    const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
    )
    ```

     1. 这里通过三元判断来决定 Proxy 的 handler 是哪个。

     2. collectionHandlers // 形参，对应的实参为：mutableCollectionHandlers，实参对应目录： packages\reactivity\src\collectionHandlers.ts

     3. baseHandlers // 形参，对应的实参为：mutableHandlers，实参对应目录：packages\reactivity\src\baseHandlers.ts

     4. 通过 demo debugger 一下看看应该走哪个：

        ```javascript
        const { createApp, reactive } = Vue
        
        debugger
        
        const data = reactive({
            a: 1,
            b: 2
        })
        
        debugger
        // data.a = 2
        console.log(data.a)
        ```

        通过上边这个 demo 可以看到 targetType === TargetType.COLLECTION 这个判定条件是不成立的，所以我们接着看 baseHandlers。

    	5. mutableHandlers 中定义了四个方法：// 以下用到的方法： track 方法收集依赖，trigger 方法触发依赖，两者第二个参数均为 typepackages\reactivity\src\effect.ts

        	1. get => createGetter

            	1. 这里的这个判断是为了解决一个边缘情况：

            ```javascript
            if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
                return Reflect.get(arrayInstrumentations, key, receiver)
            }
            ```

            ```javascript
            const obj = {}
            const arr = reactive([obj])
            arr.indexOf(obj) // -1
            ```

            上边这种情况返回的应该是 0，而不是 -1 所以为了解决这个产生了上边的那段代码。

            2. 如果 target 不是只读的则进行依赖收集 // 调用 track 收集依赖
            3. 如果 key 是 symbol / ref / shallow 都有相对应的处理
            4. 如果 key 所对应的 value 是一个对象则进行三元判断：
               1. 如果是只读的则调用 readonly 方法返回一个只读对象 // packages\reactivity\src\reactive.ts
               2. 反之调用 reactive 方法进行响应式代理

        	2. set => createSetter 

            	1. 不是浅层对象且 oldValue 是 ref 的情况
            	2. 调用 Reflect.set() 
            	3. 判断 key 在不在 target 中：
                	1. key 不存在 target 中调用 trigger 方法 type 为 add
                	2. 反之也调用 trigger 方法只不过 type 为 set

        	3. deleteProperty => 如果 target 中有 key 且 Reflect.deleteProperty() 执行成功则调用 trigger 方法触发依赖，type 为 delete

        	4. has => 调用 Reflect.has 方法成功后调用 track 方法收集依赖 type 为 has

        	5. ownKeys => 调用 track 方法收集依赖 type 为 iterate 并返回 Reflect.ownKeys() 方法的返回值

        至此，代码的整个流程就走完了，但是在看上边的代码中出现了两个方法，一个收集依赖 track 方法，一个触发依赖 trigger 方法。

## 接下来要看一下这两个方法

### track 方法

目录地址：packages\reactivity\src\effect.ts

```javascript
if (!shouldTrack || activeEffect === undefined) {
    return
}
```

这个判断条件中出现了 shouldTrack 和 activeEffect ，之前没有见到过所以我决定再 debug 一下我的 demo。

```javascript
const { createApp, reactive } = Vue

debugger

const data = reactive({
    a: 1,
    b: 2
})

debugger
// data.a = 2
console.log(data.a)
```

debug 进来之后发现 shouldTrack 为 true，activeEffect 为 undefined 所以被 return 了。这个时候有一个暂定的感觉就是通过 reactive 返回的 proxy 数据，紧接着在后边直接进行取值（data.a）的话不会进行依赖收集。

这个时候需要改一下 demo：

```javascript
const { watchEffect, createApp, reactive } = Vue


const data = reactive({
    a: 1,
    b: 2
})

// data.a = 2
// console.log(data.a)

debugger
watchEffect(() => {
    const count = data.a + 1
    console.log('count: ', count)
debugger
})
```

demo 改成这样之后 track 方法中一开始的那个判断就可以过去了。至于为什么这样可以，咱们后续解决。

这个时候 `data.a + 1` 中的 `data.a` 会触发 target 的 get 方法，在 get 方法中会执行 track 方法进行依赖收集，进入到这个方法里，可以看到之前过不去的那个判断过去了。

这个时候需要说一下 vue3 存储依赖的数据结构：

```javascript
taregetMaps: {
	target: {
		key: [
			effect // dependent
		] // set
	} // map
} // weakMap
```

继续看源码，这里就是在判断每一层有没有对应的数据结构，没有的话则 new 一个。

如果 dep 中没有包含当前的这个 activeEffect 则进行 add，后边就是对 activeEffect 的一些操作，具体这个 activeEffect 是什么，暂时先记下，后续解决。

track 方法就看完了。

### trigger 方法

定义了一个 set 类型的 effects。

定义了一个 add 方法。

判断了 type 是不是 clear 类型，又判断了是不是数组，从判断是不是数组的 if 开始到对应的 else 结束，都是在分别调用 add 方法，只不过针对不同的类型传入到 add 方法中的 deps 不一样。

来看 add 方法：

```typescript
const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
        effectsToAdd.forEach(effect => {
            if (effect !== activeEffect || effect.allowRecurse) {
                effects.add(effect)
            }
        })
    }
}
```

发现就是将传进来的 deps 进行遍历，将符合条件的每一项 add 到前边声明的 effects 中。

后边又定义了一个 run 方法。

接着遍历 effects 并调用 run 方法。

接着来看 run 方法：

```typescript
const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
        effect.options.onTrigger({
            effect,
            target,
            key,
            type,
            newValue,
            oldValue,
            oldTarget
        })
    }
    if (effect.options.scheduler) {
        effect.options.scheduler(effect)
    } else {
        effect()
    }
}
```

关于 effect.options 的操作可以暂时挂起，后续解决。这里所 get 到的就是 调用 effect 方法通知依赖。

这个时候一个完整的流程就走完了，可以 debug 走一遍看看理解的对不对。为了触发 trigger 方法，还需要更改一下我们之前的 demo：

```javascript
const { watchEffect, createApp, reactive } = Vue

const data = reactive({
    a: 1,
    b: 2,
    count: 0
})

// 收集依赖 track()
watchEffect(() => {
    /**
      * data.a // getter
      * data.count = // setter trigger()
      **/
    data.count = data.a + 1
    console.log('count: ', data.count) // getter
})
```

上边这个 demo 就可以把收集依赖和触发依赖都走一遍了。

## 上边过程中产生的问题：

- 为什么使用了 watchEffect 方法就会进行依赖收集
- track 方法中的 activeEffect 是什么，activeEffect.options.onTrack 是什么，activeEffect.deps.push() 这是什么操作，为什么要这样做。
- effect 是什么，他相关的 options 有什么

#### 为什么使用了 watchEffect 方法就会进行依赖收集

首先要看一下 track 方法中一开始的判定条件：

```javascript
if (!shouldTrack || activeEffect === undefined) {
    return
}
```

所以我们要解决也就是为什么调用了 watchEffect 方法之后这个判定条件就不会满足。

接下来进入到 watchEffect 的源码中看一看，还是通过 debug 方式。

- watchEffect 方法的定义。// packages\runtime-core\src\apiWatch.ts
- 调用 doWatch 方法。// packages\runtime-core\src\apiWatch.ts
- doWatch 方法从第三个参数中取出了 `immediate, deep, flush, onTrack, onTrigger` 这几个变量及方法

- 定义了开发环境下的一些警告和 warnInvalidSource 方法

- 定义了 `getter, forceTrigger, isMultiSource` 三个变量

- 接下来就是判断传入的 source 参数是什么类型，针对不同的类型对上边定义的变量进行赋值。    // source 接收的实参就是 vue 源码中定义的 effect。

- 断点走到上一步的时候可以看到我们传入的 effect 是一个方法并且没有 callback ，所以会进到 `isFunction` 中的 else 的判断中：

  ```javascript
  // no cb -> simple effect
  getter = () => {
      if (instance && instance.isUnmounted) {
          return
      }
      if (cleanup) {
          cleanup()
      }
      return callWithAsyncErrorHandling(
          source,
          instance,
          ErrorCodes.WATCH_CALLBACK,
          [onInvalidate]
      )
  }
  ```

- 这个方法会调用 cleanup 方法并且返回 callWithAsyncErrorHandling 方法的返回值。// 至于这两个方法分别干了什么，等代码执行到这里的时候我们再来看。

- 往下又做了对 2.x 版本的兼容

- 定义了 `cleanup ` 和 `onInvalidate` 方法

- 又做了 SSR 的处理

- 根据 isMultiSource 字段决定 oldValue 字段是一个 array 还是一个 object。// 这里 isMultiSource 是什么，现在的 demo 中会返回一个对象，那什么情况下会返回一个数组。// 这个问题后续解决

- 接下来定义了 job 方法，并增加了 allowRecurse 属性

- 接下来根据 flush 字段声明了不同的 scheduler 方法。根据我们的 demo ，scheduler 进入了 else：

  ```javascript
  // default: 'pre'
  scheduler = () => {
      if (!instance || instance.isMounted) {
          queuePreFlushCb(job)
      } else {
          // with 'pre' option, the first call must happen before
          // the component is mounted so it is called synchronously.
          job()
      }
  }
  ```

- 下边定义了一个 runner 并且接收了 effect 方法的返回值，这里执行了 effect 方法，所以需要进入到方法中看一下。// packages\reactivity\src\effect.ts

  - 在 effect 方法中先判断了传入的 fn 是不是 effect 类型
  - 接着定义了 effect 常量并且接收了 createReactiveEffect 方法的返回值，再进入到 createReactiveEffect 方法中一探究竟
    - 定义了 effect 常量，值是 reactiveEffect 方法，并且在这个方法上加了 `id, allowRecurse, _isEffect, active, raw, deps, options` 这些属性然后将 effect return。reactiveEffect 方法我们在调用到的时候再去看他。
  - 这里的 effect 顺其自然也就是 reactiveEffect 方法了。
  - 接下来又判断了是不是惰性的，如果不是则立刻执行 effect 方法
  - 将 effect 方法 return

- 执行 recordInstanceBoundEffect 方法 // packages\runtime-core\src\component.ts

  - 在代码中可以看到注释，这里是把所有 effect 都 push 到了 instance 上的 effects 的数组中，以便在组件销毁的时候停止这些依赖。
  - 可以看到虽然这里执行了这个方法，但是由于没有 instance ，在这个方法的内容是没有执行任何代码的。
  - instance 是在调用 doWatch 的时候作为第四个参数传入的，但是从前边的代码可以知道 watchEffect 方法在调用 doWatch 的时候并没有传入 instance。

- 下边的 if else 会进入到 else 中执行 runner 方法，这个 runner 方法就是在前边提到的 effect 方法的返回值 reactiveEffect 方法。

- reactiveEffect 方法如下：

  ```typescript
  const effect = function reactiveEffect(): unknown {
      if (!effect.active) {
          return fn()
      }
      if (!effectStack.includes(effect)) {
          cleanup(effect)
          try {
              enableTracking()
              effectStack.push(effect)
              activeEffect = effect
              return fn()
          } finally {
              effectStack.pop()
              resetTracking()
              activeEffect = effectStack[effectStack.length - 1]
          }
      }
  } as ReactiveEffect
  ```

  























#### track 方法中的 activeEffect 是什么，activeEffect.options.onTrack 是什么，activeEffect.deps.push() 这是什么操作，为什么要这样做。

















#### effect 是什么，他相关的 options 有什么







### 解决上边问题的时候又产生的问题

- cleanup 方法做了什么
- callWithAsyncErrorHandling 方法做了什么