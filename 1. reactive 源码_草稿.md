## 数据响应式

 1. reactive() // packages\reactivity\src\reactive.ts

 2. createReactiveObject() // packages\reactivity\src\reactive.ts

    ```javascript
    const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
    )
    ```

     1. 这里通过三元判断来决定 Proxy 的 handler 是哪个。

     2. collectionHandlers // 形参，对应的实参为：mutableCollectionHandlers，实参对应目录： packages\reactivity\src\collectionHandlers.ts

     3. baseHandlers // 形参，对应的实参为：mutableHandlers，实参对应目录：packages\reactivity\src\baseHandlers.ts

     4. 通过 demo debugger 一下看看应该走哪个：

        ```javascript
        const { createApp, reactive } = Vue
        
        debugger
        
        const data = reactive({
            a: 1,
            b: 2
        })
        
        debugger
        // data.a = 2
        console.log(data.a)
        ```

        通过上边这个 demo 可以看到 targetType === TargetType.COLLECTION 这个判定条件是不成立的，所以我们接着看 baseHandlers。

    	5. mutableHandlers 中定义了四个方法：// 以下用到的方法： track 方法收集依赖，trigger 方法触发依赖，两者第二个参数均为 typepackages\reactivity\src\effect.ts

        	1. get => createGetter

            	1. 这里的这个判断是为了解决一个边缘情况：

            ```javascript
            if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
                return Reflect.get(arrayInstrumentations, key, receiver)
            }
            ```

            ```javascript
            const obj = {}
            const arr = reactive([obj])
            arr.indexOf(obj) // -1
            ```

            上边这种情况返回的应该是 0，而不是 -1 所以为了解决这个产生了上边的那段代码。

            2. 如果 target 不是只读的则进行依赖收集 // 调用 track 收集依赖
            3. 如果 key 是 symbol / ref / shallow 都有相对应的处理
            4. 如果 key 所对应的 value 是一个对象则进行三元判断：
               1. 如果是只读的则调用 readonly 方法返回一个只读对象 // packages\reactivity\src\reactive.ts
               2. 反之调用 reactive 方法进行响应式代理

        	2. set => createSetter 

            	1. 不是浅层对象且 oldValue 是 ref 的情况
            	2. 调用 Reflect.set() 
            	3. 判断 key 在不在 target 中：
                     	1. key 不存在 target 中调用 trigger 方法 type 为 add
                     	2. 反之也调用 trigger 方法只不过 type 为 set

        	3. deleteProperty => 如果 target 中有 key 且 Reflect.deleteProperty() 执行成功则调用 trigger 方法触发依赖，type 为 delete

        	4. has => 调用 Reflect.has 方法成功后调用 track 方法收集依赖 type 为 has

        	5. ownKeys => 调用 track 方法收集依赖 type 为 iterate 并返回 Reflect.ownKeys() 方法的返回值

        至此，代码的整个流程就走完了，但是在看上边的代码中出现了两个方法，一个收集依赖 track 方法，一个触发依赖 trigger 方法。

## 接下来要看一下这两个方法

### track 方法

目录地址：packages\reactivity\src\effect.ts

```javascript
if (!shouldTrack || activeEffect === undefined) {
    return
}
```

这个判断条件中出现了 shouldTrack 和 activeEffect ，之前没有见到过所以我决定再 debug 一下我的 demo。

```javascript
const { createApp, reactive } = Vue

debugger

const data = reactive({
    a: 1,
    b: 2
})

debugger
// data.a = 2
console.log(data.a)
```

debug 进来之后发现 shouldTrack 为 true，activeEffect 为 undefined 所以被 return 了。这个时候有一个暂定的感觉就是通过 reactive 返回的 proxy 数据，紧接着在后边直接进行取值（data.a）的话不会进行依赖收集。

这个时候需要改一下 demo：

```javascript
const { watchEffect, createApp, reactive } = Vue


const data = reactive({
    a: 1,
    b: 2
})

// data.a = 2
// console.log(data.a)

debugger
watchEffect(() => {
    const count = data.a + 1
    console.log('count: ', count)
debugger
})
```

demo 改成这样之后 track 方法中一开始的那个判断就可以过去了。至于为什么这样可以，咱们后续解决。

这个时候 `data.a + 1` 中的 `data.a` 会触发 target 的 get 方法，在 get 方法中会执行 track 方法进行依赖收集，进入到这个方法里，可以看到之前过不去的那个判断过去了。

这个时候需要说一下 vue3 存储依赖的数据结构：

```javascript
taregetMaps: {
	target: {
		key: [
			effect // dependent
		] // set
	} // map
} // weakMap
```

继续看源码，这里就是在判断每一层有没有对应的数据结构，没有的话则 new 一个。

如果 dep 中没有包含当前的这个 activeEffect 则进行 add，后边就是对 activeEffect 的一些操作，具体这个 activeEffect 是什么，暂时先记下，后续解决。

track 方法就看完了。

### trigger 方法

定义了一个 set 类型的 effects。

定义了一个 add 方法。

判断了 type 是不是 clear 类型，又判断了是不是数组，从判断是不是数组的 if 开始到对应的 else 结束，都是在分别调用 add 方法，只不过针对不同的类型传入到 add 方法中的 deps 不一样。

来看 add 方法：

```typescript
const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {
    if (effectsToAdd) {
        effectsToAdd.forEach(effect => {
            if (effect !== activeEffect || effect.allowRecurse) {
                effects.add(effect)
            }
        })
    }
}
```

发现就是将传进来的 deps 进行遍历，将符合条件的每一项 add 到前边声明的 effects 中。

后边又定义了一个 run 方法。

接着遍历 effects 并调用 run 方法。

接着来看 run 方法：

```typescript
const run = (effect: ReactiveEffect) => {
    if (__DEV__ && effect.options.onTrigger) {
        effect.options.onTrigger({
            effect,
            target,
            key,
            type,
            newValue,
            oldValue,
            oldTarget
        })
    }
    if (effect.options.scheduler) {
        effect.options.scheduler(effect)
    } else {
        effect()
    }
}
```

关于 effect.options 的操作可以暂时挂起，后续解决。这里所 get 到的就是 调用 effect 方法通知依赖。

这个时候一个完整的流程就走完了，可以 debug 走一遍看看理解的对不对。为了触发 trigger 方法，还需要更改一下我们之前的 demo：

```javascript
const { watchEffect, createApp, reactive } = Vue

const data = reactive({
    a: 1,
    b: 2,
    count: 0
})

// 收集依赖 track()
watchEffect(() => {
    /**
      * data.a // getter
      * data.count = // setter trigger()
      **/
    data.count = data.a + 1
    console.log('count: ', data.count) // getter
})
```

上边这个 demo 就可以把收集依赖和触发依赖都走一遍了。

## 上边过程中产生的问题：

- 为什么使用了 watchEffect 方法就会进行依赖收集
- track 方法中的 activeEffect 是什么，activeEffect.options.onTrack 是什么，activeEffect.deps.push() 这是什么操作，为什么要这样做。
- trigger 方法中定义的 run 方法中的 effect 是什么，他相关的 options 有什么

#### 为什么调用了 watchEffect 方法就会进行依赖收集

首先要看一下 track 方法中一开始的判定条件：

```javascript
if (!shouldTrack || activeEffect === undefined) {
    return
}
```

所以我们要解决也就是为什么调用了 watchEffect 方法之后这个判定条件就不会满足。

接下来进入到 watchEffect 的源码中看一看，还是通过 debug 方式。

- watchEffect 方法的定义。// packages\runtime-core\src\apiWatch.ts

- 调用 doWatch 方法。// packages\runtime-core\src\apiWatch.ts

- doWatch 方法从第三个参数中取出了 `immediate, deep, flush, onTrack, onTrigger` 这几个变量及方法

- 定义了开发环境下的一些警告和 warnInvalidSource 方法

- 定义了 `getter, forceTrigger, isMultiSource` 三个变量

- 接下来就是判断传入的 source 参数是什么类型，针对不同的类型对上边定义的变量进行赋值。    // source 接收的实参就是 vue 源码中定义的 effect。

- 断点走到上一步的时候可以看到我们传入的 effect 是一个方法并且没有 callback ，所以会进到 `isFunction` 中的 else 的判断中，这里对 getter 进行了赋值：

  ```javascript
  // no cb -> simple effect
  getter = () => {
      if (instance && instance.isUnmounted) {
          return
      }
      if (cleanup) {
          cleanup()
      }
      return callWithAsyncErrorHandling(
          source,
          instance,
          ErrorCodes.WATCH_CALLBACK,
          [onInvalidate]
      )
  }
  ```

- 这个方法会调用 cleanup 方法并且返回 callWithAsyncErrorHandling 方法的返回值。// 至于这两个方法分别干了什么，等代码执行到这里的时候我们再来看。

- 往下又做了对 2.x 版本的兼容

- 定义了 `cleanup ` 和 `onInvalidate` 方法

- 又做了 SSR 的处理

- 根据 isMultiSource 字段决定 oldValue 字段是一个 array 还是一个 object。// 这里 isMultiSource 是什么，现在的 demo 中会返回一个对象，那什么情况下会返回一个数组。// 这个问题后续解决

- 接下来定义了 job 方法，并增加了 allowRecurse 属性

- #### 接下来根据 flush 字段声明了不同的 scheduler 方法。根据我们的 demo ，scheduler 进入了 else：

  ```javascript
  // default: 'pre'
  scheduler = () => {
      if (!instance || instance.isMounted) {
          queuePreFlushCb(job)
      } else {
          // with 'pre' option, the first call must happen before
          // the component is mounted so it is called synchronously.
          job()
      }
  }
  ```

- 下边定义了一个 runner 并且接收了 effect 方法的返回值，这里执行了 effect 方法，所以需要进入到方法中看一下。// packages\reactivity\src\effect.ts

  - 在 effect 方法中先判断了传入的 fn 是不是 effect 类型
  - 接着定义了 effect 常量并且接收了 createReactiveEffect 方法的返回值，再进入到 createReactiveEffect 方法中一探究竟
    - 定义了 effect 常量，值是 reactiveEffect 方法，并且在这个方法上加了 `id, allowRecurse, _isEffect, active, raw, deps, options` 这些属性然后将 effect return。reactiveEffect 方法我们在调用到的时候再去看他。
  - 这里的 effect 顺其自然也就是 reactiveEffect 方法了。
  - 接下来又判断了是不是惰性的，如果不是则立刻执行 effect 方法
  - 将 effect 方法 return

- 执行 recordInstanceBoundEffect 方法 // packages\runtime-core\src\component.ts

  - 在代码中可以看到注释，这里是把所有 effect 都 push 到了 instance 上的 effects 的数组中，以便在组件销毁的时候停止这些依赖。
  - 可以看到虽然这里执行了这个方法，但是由于没有 instance ，在这个方法的内容是没有执行任何代码的。
  - instance 是在调用 doWatch 的时候作为第四个参数传入的，但是从前边的代码可以知道 watchEffect 方法在调用 doWatch 的时候并没有传入 instance。

- 下边的 if else 会进入到 else 中执行 runner 方法，这个 runner 方法就是在前边提到的 effect 方法的返回值 reactiveEffect 方法。

- #### reactiveEffect 方法如下

  ```typescript
  const effect = function reactiveEffect(): unknown {
      if (!effect.active) {
          return fn()
      }
      if (!effectStack.includes(effect)) {
          cleanup(effect)
          try {
              enableTracking()
              effectStack.push(effect)
              activeEffect = effect
              return fn()
          } finally {
              effectStack.pop()
              resetTracking()
              activeEffect = effectStack[effectStack.length - 1]
          }
      }
  } as ReactiveEffect
  ```

  - 方法里边执行了 cleanup 方法，前边对这个 cleanup 方法有疑问，现在进入到这个方法中一探究竟。这个方法其实就是将传入方法的 effect 中存放依赖的 deps 取出来，将这个数组清空。

  - 这里为什么要进行清空呢，这里的 effect.deps 不应该就是记录了谁依赖于这个 effect 吗，为什么要清空呢这个问题后续来解决。
  - 接下来执行 enableTracking 方法，这个方法里做了两件事，一个是把当前页面声明的 shouldTrack push 到 trackStack 中，另外一件事是将 shouldTrack 置为 true。
  - 然后又把 effect push 到了当前页面中声明的 effectStack 中，并且把 effect 赋值给了 activeEffect 。截至到这一步，我们可以暂时回答我们的问题了，为什么调用了 watchEffect 方法就会进行依赖收集。因为在这里会对 activeEffect 进行赋值，赋值之后在我们的 track 方法中就不会被 return 掉，所以可以进行依赖收集。这个回答只是暂时的，因为方法还没有走完，需要走完之后才能确定下来。那么继续。
  - 然后开始执行 fn 方法，这里是利用了闭包，调用的是外层函数传入进来的 fn，这里的 fn 是 doWatch 方法中的 getter。
    - 在 getter 中前边的判断都没有满足，直接调用了 callWithAsyncErrorHandling 方法，我们在前边也对这个方法有疑问，现在去看一下。// packages\runtime-core\src\errorHandling.ts
    - 方法传入的 fn 其实就是我们在最外层调用 watchEffect 的时候传入的那个方法
    - 这里先判断了是不是 function，我们这个 demo 满足，然后调用了 callWithErrorHandling 方法
      - 在这个方法里执行了 fn，并且在 执行的时候进行了 try catch。走到这里我们可以得知，**我们在主动调用 watchEffect 的时候会主动的执行一次我们传入的方法，并不是等到这个方法内的依赖项有变动的时候才执行第一次。** 执行完成之后会将我们传入的这个方法的返回值 return 出去。
      - 再往下看这个方法的代码，可以知道，**watchEffect 方法不仅可以传入一个 Function 的数据 ，也可以传入一个 Array 类型的数据。**
  - 上边执行完成则又对 effectStack 执行了 pop() 
  - 接着调用了 resetTracking 方法，该方法是对前边提到的 trackStack 执行 pop 方法 和根据 trackStack.pop() 的返回值对 shouldTrack 进行处理。
  - 对 activeEffect 也进行了重新赋值，将 effectStack 数组中的最后一个赋值给了他。
  - 这一系列的只对数组的最后一个进行操作是为什么呢：猜测是因为前边执行 enableTracking 方法和 effectStack 数组的操作都是进行的 push，所以为了不影响之前的数据，在这里进行了 pop()。
  
- 后边 return 了一个函数：

  ```typescript
  return () => {
      stop(runner) // 停止对当前 effect 的响应
      if (instance) {
          // 将实例移除
          remove(instance.effects!, runner)
      }
  }
  ```
- watchEffect 方法到这里就结束了。

  **最终的结论就是和我们前边给出的一样：**

  **为什么调用了 watchEffect 方法就会进行依赖收集。因为在 reactiveEffect 方法中会对 activeEffect 进行赋值，赋值之后在我们的 track 方法中就不会被 return 掉，所以可以进行依赖收集。**

  

#### track 方法中的 activeEffect 是什么，activeEffect.options.onTrack 是什么。

​	activeEffect 是定义在 effect.ts 文件中的一个全局变量，那么他的值是什么呢，通过前边的代码可以知道 activeEffect 是在 createReactiveEffect 方法中的闭包函数 reactiveEffect 进行赋值的，`activeEffect = effect` 而 `const effect = function reactiveEffect() {}` 最终 activeEffect 等于 `function reactiveEffect() {}` 这个方法里会执行 fn ，fn 也就是在doWatch 中定义的 getter 方法，这里也是我们调用 watchEffect 时传入的方法会立即执行的入口，因为在这个方法中会去调用它。这个方法内具体会干什么，[前边](reactiveEffect 方法如下)已经说过。这个变量的作用就目前已知的来看也是为了能够在其他方法中调用到 reactiveEffect 方法，并且在 track 方法中可以看到，收集依赖其实收集的就是 reactiveEffect 方法。

#### activeEffect.deps.push() 这是什么操作，为什么要这样做

​	语义上来看是将当前 key 所对应的 dep push 到了 activeEffect 的 deps 中，但是为什么要这样做还有待思考。网上查了一番，[这篇文章写的还是很不错的，对这个问题点也有一定的解析。](https://juejin.cn/post/6909698939696447496#heading-14)

文章内的总结：activeEffect.deps.push() 这个操作是在为之前在 reactiveEffect 方法中提到的 cleanup 方法做准备，每次收集 activeEffect 之前，会先将 activeEffect 中的 deps 清空，然后再进行收集依赖。先清空再收集就是为了避免如果 activeEffect 中有在特定条件下才会触发的依赖收集，之前已经收集过了，但是这次不需要收集，所以会先把之前收集的清空掉，然后再针对当前这次需要收集的依赖进行收集，保证当前收集的依赖肯定是当前需要被收集的。

#### trigger 方法中定义的 run 方法中的 effect 是什么，他相关的 options 有什么

- 这里的 effect 其实就是前边说到的 activeEffect。

- options 里边有什么其实在 doWatch 方法中就可以看到

  ```typescript
  const runner = effect(getter, {
      lazy: true,
      onTrack,
      onTrigger,
      scheduler
  })
  ```

  这里传入的花括号就是对应的 options。

  - lazy 标识懒加载，默认值为true，在 effect 方法中可以看到如果 lazy 为 false，则立刻执行 effect 方法。这里的 lazy 应该和 watch 中的 lazy 有着千丝万缕的关系。// 由此产生的问题：watch 和 watchEffect 的关系，我们后续解决。
  - onTrack 和 onTrigger 从代码上看应该是开发环境下用于监听收集和触发依赖便于调试用的。
  - scheduler 方法我们在[前边](接下来根据 flush 字段声明了不同的 scheduler 方法。根据我们的 demo ，scheduler 进入了 else：)提到过它的定义，根据传入的 flush 来决定了当前这个 watchEffect 的执行时机。

### 解决上边问题的时候又产生的问题

- cleanup 方法做了什么，为什么在收集依赖之前要将当前这个 effect 的 deps 清空呢。

  这个问题在 [activeEffect.deps.push() 这是什么操作，为什么要这样做](activeEffect.deps.push() 这是什么操作，为什么要这样做) 中已有答案

- callWithAsyncErrorHandling 方法做了什么

  这个问题在上边也有答案：

  - 这里先判断了是不是 function，我们这个 demo 满足，然后调用了 callWithErrorHandling 方法

  - 在这个方法里执行了 fn，并且在 执行的时候进行了 try catch。走到这里我们可以得知，**我们在主动调用 watchEffect 的时候会主动的执行一次我们传入的方法，并不是等到这个方法内的依赖项有变动的时候才执行第一次。** 执行完成之后会将我们传入的这个方法的返回值 return 出去。
  - 再往下看这个方法的代码，可以知道，**watchEffect 方法不仅可以传入一个 Function 的数据 ，也可以传入一个 Array 类型的数据。**