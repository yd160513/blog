# 前言

自己的算法有些许的薄弱，决定开撕算法。

望自己能够坚持下去！！！

# 二分查找

## 定义

小时候应该玩过一种猜字游戏: 小朋友 A 心里想着一个 1 到 100 之前的数字，小朋友 B 需要猜到 A 心中的这个字，在猜的过程中 A 会提示 B 猜的数字是大了还是小了。

那么在猜的过程中怎么才能最快的猜到呢？有了这个问题，二分查找的定义也就产生了: 

在一个有序的数组中需要找到某一个目标值的时候，可以每次都去判断中间的那个值是不是目标值，如果是则返回；如果不是则用这个值和数组的开头的值或者结束的值组成一个新的区间，然后在这个新区间中再次判断中间值。一直循环这个操作，直到找到或者找不到为止。

## 场景

在一个有序数组中，查找某目标个值是否存在这个数组中，如果存在则将其对应的索引返回，反之返回一个 -1

### 流程

1. 根据二分的定义，需要定义一个开始索引和一个结束索引，用来表示动态区间
2. 取区间的中间值，如果中间值等于目标值则 return 其索引并结束循环
3. 如果中间值大于目标值，则说明目标值在中间值和第一个值之间
4. 如果中间值小于目标值，则说明目标值在中间值和最后一个值之间
5. 经过 4 或者 5 的判断则可以形成一个新的区间，然后在这个新的区间重复 2 - 4

### 图解

![image-20210830170815194](/Users/kouyidong/Library/Application Support/typora-user-images/image-20210830170815194.png)

### 代码实现

```typescript
function binarySearch(list, target) {
  let startIndex = 0
  let endIndex = list.length - 1
  while(startIndex <= endIndex) {
    let middleIndex = Math.floor((startIndex + endIndex) / 2)
    let middleValue = list[middleIndex]
    if (middleValue === target) {
      return middleIndex
    } else if (middleValue > target) {
      endIndex = middleIndex - 1
    } else if (middleValue < target) {
      startIndex = middleIndex + 1
    }
  }
  return -1
}
```

### 问题

- 为什么在 middleValue > target 和 middleValue < target 中要对 middleIndex 进行减一、加一？

  因为当前中间值已经比较过了，并不等于目标值，所以需要进行加一减一让他指向新的值

- while 循环的条件可不可以是 startIndex < endIndex ？

  不可以，因为 startIndex 是会等于 endIndex 的。 

- 取中间值的 (startIndex + endIndex) / 2 为什么要向下取整？

  如果不取整则数组 length 为偶数的时候 /2 就会出现小数；

  如果想上取整，则会出现大于数组长的索引，那个时候会取不到值。

## 关键字

设置动态区间，遍历动态区间，取区间中间值和 target 判断。

# 冒泡排序

## 流程

1. 从第一个元素开始比较数组中相邻的两个元素
2. 如果前边的大于后边的那个则互换位置，反之保持不变
3. 一直重复 2 ，直到数组的最后一个
4. 当比较完成之后数组的最后一个肯定就是数组中最大的了
5. 开启下一轮循环，重复 1 - 5 直到数组所有元素比较完成
6. 5 执行完成之后只能确定最后一个值的位置，其他值还需要重新进行比较，所以需要在外层套一个循环来控制循环次数

## 图解

![image-20210830172345980](/Users/kouyidong/Library/Application Support/typora-user-images/image-20210830172345980.png)

## 代码实现

```typescript
function bubbleSort(list) {
  for (let i = 0; i < list.length - 1; i++) {
    for (let k = 0; k < list.length - 1 - i; k++) {
      if (list[k] > list[k + 1]) {
        const temp = list[k]
        list[k] = list[k + 1]
        list[k + 1] = temp
      }
    }
  }
  return list
}
```

## 问题

- 外层循环的条件中为什么是 i < list.length - 1 ?

  按照图解中的 demo 来说，条件如果是 i < list.length 的话，则相当于是 i < 8，结束条件前的最后一次循环就是 i = 7，当为 7 遍历的时候这个数组的顺序在 i = 6 的时候就已经是正确的了，所以 i = 7 的时候循环相当于是空循环了一次，所以干脆就直接不循环了。

- 内层循环为什么要 - i ?

  当第一次比较完成之后，数组的最后一个肯定是最大的了，所以在下次就不需要比对最后一个。

  第一次是最后一个不需要比较，第二次是最后两个不需要...

  最终可以得出: 外层循环的次数就是已经比对过的次数，也就是数组后边不需要比对的个数，所以将其减去。

## 关键字

相邻的两个元素挨个比较，每次只能确定最后一个值的位置。

# 选择排序

## 流程

1. 将第一个值的索引存起来，假设其对应值为最小值
2. 循环数组用最小值依次和最小值后边的值进行比较
3. 期间如果有小于最小值的，则将之前的最小值的索引进行替换
4. 循环完成之后如果初始化时存的最小值不等于最终的最小值，则将两个位置进行替换
5. 4 完成之后则可以确定最小值的位置
6. 重复 1 -5 ，只不过这次需要将第二个值的索引存起来。

## 图解

![image-20210830181732579](/Users/kouyidong/Library/Application Support/typora-user-images/image-20210830181732579.png)

## 代码实现

```typescript
function selectSort(list) {
  for (let i = 0; i < list.length - 1; i++) {
    let cache = i
    for (let k = i + 1; k < list.length; k++) {
      if (list[k] < list[cache]) {
        cache = k
      }
    }
    if (cache !== i) {
      const temp = list[cache]
      list[cache] = list[i]
      list[i] = temp
    }
  }
  return list
}
```

## 注意点

```typescript
if (list[k] < list[cache]) {
  cache = k
}
```

在个判断中取到更小的值之后没有结束内层循环，而是继续遍历，这里不可以将内层循环结束，因为有可能当前找到值并不是最小的，最小的有可能还在后边。

## 关键字

选择第一个为最小值，遍历其后边的值最终将最小值优先确定。

# 插入排序

## 流程

1. 将数组的第二个值缓存起来定义为 cache
2. 然后把 cache 左边的值挨个儿和 cache 作比较
3. 如果 cache 左边的某个值大于 cache 则两个值互换位置，然后 cache 的索引替换为这个值的索引
4. 如果左侧的值小于被缓存的值了，则将被缓存的值插入到当前索引的位置并结束次轮循环
5. 如果左侧没有值了也就是 k = 0 的时候则结束此轮循环。

## 图解



## 代码实现

```typescript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    const cache = arr[i];
    let k = i
    for (; k > 0; k--) {
			if (arr[k - 1] < cache) break
      arr[k] = arr[k - 1]
    }
    arr[k] = cache
  }
  return arr
}
```

## 关键字







# 散列表



# 栈和队列



# 递归



# 链表



# 二叉树



# 总结

