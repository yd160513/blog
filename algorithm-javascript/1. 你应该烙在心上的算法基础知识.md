# 前言



# 二分查找

## 定义

小时候应该玩过一种猜字游戏: 小朋友 A 心里想着一个 1 到 100 之前的数字，小朋友 B 需要猜到 A 心中的这个字，在猜的过程中 A 会提示 B 猜的数字是大了还是小了。

那么在猜的过程中怎么才能最快的猜到呢？有了这个问题，二分查找的定义也就产生了: 

在一个有序的数组中需要找到某一个目标值的时候，可以每次都去判断这个数组中中间的那个值是不是我们想要的，如果不是，则可以排除掉一半的答案。一直循环下去，每次都是猜中间的那个值，直到直到目标值即可。

## 场景

在一个有序数组中，查找某目标个值是否存在这个数组中，如果存在则将其对应的索引返回，反之返回一个 null

### 实现流程

1. 对传入的数组要根据猜测的值定义成一个区间
2. 因为每循环一遍都需要定义出一个新的区间来，所以定义一个开始索引和一个结束索引，用来表示这个新的区间
3. 开始循环遍历这个区间，循环的结束条件就是开始索引大于了结束索引
4. 如果开始索引大于了结束索引说明区间已经遍历完了但是还没有找到
5. 在遍历中获取区间的中间值
   1. 如果中间值等于目标值则将中间值的索引 return
   2. 如果中间值大于目标值则说明目标值在中间值往前的这个区间中，则将中间值减一设置为新的结束索引
   3. 如果中间值小于目标值则说明目标值在中间值往后的这个区间中，则将中间值加一设置为新的开始索引

> 减一、加一的原因: 因为当前中间值已经比较过了，并不等于目标值，所以需要进行加一减一让他指向新的值

### 代码

```typescript
function binarySearch(list, target) {
  let startIndex = 0
  let endIndex = list.length - 1
  while(startIndex <= endIndex) {
    let middleIndex = Math.floor((startIndex + endIndex) / 2)
    let middleValue = list[middleIndex]
    if (middleValue === target) {
      return middleIndex
    } else if (middleValue > target) {
      endIndex = middleIndex - 1
    } else if (middleValue < target) {
      startIndex = middleIndex + 1
    }
  }
  return -1
}
```

### 问题

- while 循环的条件可不可以是 startIndex < endIndex

  不可以，因为 startIndex 是会等于 endIndex 的。

- 取中间值的 (startIndex + endIndex) / 2 为什么要向下取整 Math.floor ？

  如果不取整则数组 length 为偶数的时候 /2 就会出现小数；

  如果想上取整，则会出现大于数组长的索引，那个时候会取不到值。

## 关键字



# 冒泡排序

## 实现流程

1. 需要循环 array.length 轮
2. 第一轮比较相邻的两个元素，是第一个和第二个比较
3. 如果第一个比第二个大，则交换位置，反之不做处理
4. 然后第二个和第三个比较，规则同 2 
5. 然后第三个和第四个、第四个和第五个...
6. 直到数组的最后一个
7. 当比到数组的最后一个的时候，数组的最后一个肯定就是数组中最大的了
8. 这个时候开始第二轮，在第二轮比较的时候，因为在第一轮中数组最后一个值的位置已经确定，所以在第二轮中也就可以不用去比对最后一个值了。
9. 直到一直循环 array.length 轮

## 代码

```typescript
function bubbleSort(list) {
  for (let i = 0; i < list.length - 1; i++) {
    for (let k = 0; k < list.length - 1 - i; k++) {
      if (list[k] > list[k + 1]) {
        const temp = list[k]
        list[k] = list[k + 1]
        list[k + 1] = temp
      }
    }
  }
  return list
}
```

## 关键字



# 选择排序

## 实现流程

1. 第一轮循环的时候将第一个值的索引存起来，将其假设为最小值
2. 后边依次和存起来的索引对应的值作比较
3. 如果有比这个值小的，则将这个更小的值的索引存起来
4. 比较完成之后将一开始缓存起来的索引和最新缓存的索引作对比，如果不相等则说明顺序有变化
5. 将旧的索引和新的索引对应的值互换位置
6. 开启第二轮循环，重复 1 - 6，直到数组所有元素都比较完成

## 代码

```typescript
function selectSort(list) {
  for (let i = 0; i < list.length - 1; i++) {
    let cache = i
    for (let k = i + 1; k < list.length; k++) {
      if (list[k] < list[cache]) {
        cache = k
      }
    }
    if (cache !== i) {
      const temp = list[cache]
      list[cache] = list[i]
      list[i] = temp
    }
  }
  return list
}
```

## 关键字





# 插入排序

## 实现流程

1. 第一轮循环将数组的第二个值缓存起来定义为 cache
2. 然后把 cache 左边的值挨个儿和 cache 作比较
3. 如果 cache 左边的某个值大于 cache 则两个值互换位置，然后 cache 的索引替换为这个值的索引
4. 如果左侧的值小于被缓存的值了，则将被缓存的值插入到当前索引的位置并结束次轮循环
5. 如果左侧没有值了也就是 k = 0 的时候则结束此轮循环。。

## 代码

```typescript
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    const cache = arr[i];
    let k = i
    for (; k > 0; k--) {
			if (arr[k - 1] < cache) break
      arr[k] = arr[k - 1]
    }
    arr[k] = cache
  }
  return arr
}
```

## 关键字







# 散列表



# 栈和队列



# 递归



# 链表



# 二叉树



# 总结

